<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ STL用法</title>
    <url>/2021/02/04/STL/</url>
    <content><![CDATA[<p>C++ STL常见容器的用法。</p>
<a id="more"></a>
<p><strong>序列容器：</strong> vector deque list  [ 线性数据结构 ]</p>
<p><strong>关联容器：</strong> set multiset map multimap  [ 非线性数据结构  能够快速找出保存在容器中的元素]</p>
<p><strong>容器适配器：</strong>  stack queue priority_queue</p>
<h4 id="1-string容器"><a href="#1-string容器" class="headerlink" title="1.string容器"></a>1.string容器</h4><p>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str;      </span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">int</span> n, <span class="keyword">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br></pre></td></tr></table></figure>
<p>赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* s);*<span class="comment">//char\*类型字符串 赋值给当前的字符串* </span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);*<span class="comment">//把字符串s赋给当前的字符串* </span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">char</span> c);*<span class="comment">//字符赋值给当前的字符串</span></span><br></pre></td></tr></table></figure>
<p>string拼接操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="keyword">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">append</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>
<p>string查找和替换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">replace</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>
<p>string子串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> pos = <span class="number">0</span>, <span class="keyword">int</span> n = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>
<p>插入和删除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符 </span></span><br></pre></td></tr></table></figure>
<p>string和c-style字符串转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line"><span class="comment">//char* 转 string </span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;it&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2.vector容器"></a>2.vector容器</h4><blockquote>
<p>vector维护一个线性空间，所以不论元素的型别如何，<strong>普通指针</strong>都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如operaroe*, operator-&gt;, operator++, operator–, operator+, operator-, operator+=, operator-=, 普通指针天生具备。</p>
</blockquote>
<p>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.begin(), v.end());<span class="comment">//将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> <span class="built_in">vector</span> &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子 使用第二个构造函数 我们可以...</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>; </span><br></pre></td></tr></table></figure>
<p>大小操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line">resize(<span class="keyword">int</span> num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">resize(<span class="keyword">int</span> num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class="line">capacity();<span class="comment">//容器的容量</span></span><br><span class="line">reserve(<span class="keyword">int</span> len);<span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>
<p>插入和删除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">insert(const_iterator pos, <span class="keyword">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line">push_back(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line">pop_back();<span class="comment">//删除最后一个元素</span></span><br><span class="line">erase(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line">erase(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line">clear();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>
<p><strong>优化方法</strong></p>
<p>1.提前分配足够的空间以避免不必要的重新分配和复制周期 reserve()</p>
<blockquote>
<p>当vector <strong>预留空间不足</strong>时</p>
<p>常用操作push_back()函数在<strong>每次插入元素时</strong>会检测预留空间是否够用</p>
<p>预留空间不够用：要重<strong>新分配内存</strong>，并且<strong>拷贝</strong>当前已有的所有元素到新的内存区域。如果已有元素很多，这个操作将变的非常昂贵。</p>
</blockquote>
<p>2.使用 shrink_to_fit() 释放 vector 占用的内存， – clear() 或 erase() 不会释放内存。</p>
<p>3.在 vector 前部做的插入操作其复杂度都是 O(n) 。</p>
<h4 id="3-deque容器"><a href="#3-deque容器" class="headerlink" title="3.deque容器"></a>3.deque容器</h4><p>双向开口的连续线性空间。</p>
<p>与vector容器的差异：</p>
<p>1.deque允许使用常数项时间对头端进行元素的插入和删除操作。</p>
<p>2.deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。</p>
<p>deque双端插入和删除操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line">pop_back();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line">pop_front();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure>
<p>deque插入操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">insert(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure>
<p>deque删除操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>
<h4 id="4-stack容器"><a href="#4-stack容器" class="headerlink" title="4.stack容器"></a>4.stack容器</h4><p><strong>stack没有迭代器</strong></p>
<p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。</p>
<p>stack数据存取操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line">pop();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line">top();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<p>stack大小操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">empty();<span class="comment">//判断堆栈是否为空</span></span><br><span class="line">size();<span class="comment">//返回堆栈的大小</span></span><br></pre></td></tr></table></figure>
<h4 id="5-queue容器"><a href="#5-queue容器" class="headerlink" title="5.queue容器"></a>5.queue容器</h4><p>queue存取、插入和删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line">pop();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line">back();<span class="comment">//返回最后一个元素</span></span><br><span class="line">front();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure>
<h4 id="6-list容器"><a href="#6-list容器" class="headerlink" title="6.list容器"></a>6.list容器</h4><ul>
<li><p>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p>
</li>
<li><p>List容器是一个双向链表。</p>
</li>
</ul>
<p>list插入和删除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line">pop_back();<span class="comment">//删除容器中最后一个元素</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器开头插入一个元素</span></span><br><span class="line">pop_front();<span class="comment">//从容器开头移除第一个元素</span></span><br><span class="line">insert(pos,elem);<span class="comment">//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line">remove(elem);<span class="comment">//删除容器中所有与elem值匹配的元素。</span></span><br></pre></td></tr></table></figure>
<p>list大小操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line">resize(num);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);<span class="comment">//重新指定容器的长度为num，</span></span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure>
<h4 id="7-set-multiset容器"><a href="#7-set-multiset容器" class="headerlink" title="7. set/multiset容器"></a>7. set/multiset容器</h4><p>Set的特性是所有元素都会根据元素的键值自动被排序。</p>
<p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p>
<p>set和multiset的底层实现是红黑树。</p>
<p>插入和删除操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">insert(elem);<span class="comment">//在容器中插入元素。</span></span><br><span class="line">clear();<span class="comment">//清除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg, end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(elem);<span class="comment">//删除容器中值为elem的元素。</span></span><br></pre></td></tr></table></figure>
<p>set查找操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line">count(key);<span class="comment">//查找键key的元素个数</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>
<p><strong>pair对组</strong></p>
<ul>
<li><p>pair将一对值组合成一个值</p>
</li>
<li><p>这一对值可以具有不同的数据类型</p>
</li>
<li><p>两个值可以分别用pair的两个公有函数first和second访问。</p>
</li>
</ul>
<p>构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make_pair</span>(v1, v2); </span><br></pre></td></tr></table></figure>
<h4 id="8-map-multimap容器"><a href="#8-map-multimap容器" class="headerlink" title="8.map/multimap容器"></a>8.map/multimap容器</h4><ul>
<li><p>Map的特性是，所有元素都会根据元素的键值自动排序。</p>
</li>
<li><p>Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p>
</li>
</ul>
<p>map插入数据：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert(...); <span class="comment">//往容器插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStu;</span><br><span class="line"><span class="comment">// 第一种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&quot;小张&quot;</span>));</span><br><span class="line"><span class="comment">// 第二种 通过pair的方式插入对象</span></span><br><span class="line">mapStu.inset(<span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="string">&quot;校长&quot;</span>));</span><br><span class="line"><span class="comment">// 第三种 通过value_type的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">1</span>, <span class="string">&quot;小李&quot;</span>));</span><br><span class="line"><span class="comment">// 第四种 通过数组的方式插入值</span></span><br><span class="line">mapStu[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;</span><br><span class="line">mapStu[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>map删除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clear();<span class="comment">//删除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line">erase(keyElem);<span class="comment">//删除容器中key为keyElem的对组。</span></span><br></pre></td></tr></table></figure>
<p>map查找：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span></span><br><span class="line">count(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器。</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器。</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2021/02/04/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>之前学的排序感觉有点生疏了，复习重温一下十大排序算法。</p>
<a id="more"></a>
<p><strong>十大排序算法比较</strong></p>
<p>前七种为比较排序，后三种为非比较排序。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">时间复杂度（平均）</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(n\log_2n)$</td>
<td style="text-align:center">$O(\log_2n)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n^{1.3})$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(n\log_2n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(n\log_2n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$O(n*k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h4><ul>
<li><p>从列表中选出一个元素，作为“基准”pivot，基准一般随机选择，或采用<strong>最左端、最右端和中间位置3元素的中值</strong>；</p>
</li>
<li><p>当数据量很小（N&lt;=20）时，快速排序效果不如插入排序，因为快速排序不稳定且有递归开销。</p>
</li>
<li><p>递归写法</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选则最左端、最右端和中间位置3元素的中值作为基准值，并将3元素排序，返回基准值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">medianPovit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left] &gt; <span class="built_in">array</span>[mid])&#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[mid], <span class="built_in">array</span>[left]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left] &gt; <span class="built_in">array</span>[right])&#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[mid] &gt; <span class="built_in">array</span>[right])&#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[mid], <span class="built_in">array</span>[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[mid];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分区,返回基准索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中间位置索引</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 基准值（此时基准值对应索引为mid）</span></span><br><span class="line">    <span class="keyword">int</span> povit = medianPovit(<span class="built_in">array</span>, left, mid, right);</span><br><span class="line">    <span class="comment">// 将基准值与倒数第二个元素交换</span></span><br><span class="line">    <span class="built_in">array</span>[mid] = <span class="built_in">array</span>[right - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">array</span>[right - <span class="number">1</span>] = povit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt; povit) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt;= povit) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换基准值和i位置元素</span></span><br><span class="line">    swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[right - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSortHelp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotLoction = partition(<span class="built_in">array</span>, left, right);</span><br><span class="line">        quickSortHelp(<span class="built_in">array</span>, left, pivotLoction - <span class="number">1</span>);</span><br><span class="line">        quickSortHelp(<span class="built_in">array</span>, pivotLoction + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    quickSortHelp(<span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h4><p>第一个突破$O(n^2)$的排序算法，是简单插入排序的改进版。</p>
<p>先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">array</span>.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 使用插入排序算法，将元素依次插入所在小组的已排序列表中</span></span><br><span class="line">            <span class="comment">// 待插入元素</span></span><br><span class="line">            <span class="keyword">int</span> itermToInsert = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt;= itermToInsert)&#123;</span><br><span class="line">                <span class="built_in">array</span>[j + gap] = <span class="built_in">array</span>[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">array</span>[j + gap] = itermToInsert;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调整堆，根元素沿树向下移动，直至其合适位置，first和last分别为堆顶和堆底在数组array中的索引</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveDown</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="comment">// first的左子节点索引</span></span><br><span class="line">    <span class="keyword">int</span> curIndex = first * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (curIndex &lt;= last)&#123;</span><br><span class="line">        <span class="comment">// 若first有2子节点，令curIndex为其值最大子节点索引</span></span><br><span class="line">        <span class="keyword">if</span> (curIndex &lt; last &amp;&amp; <span class="built_in">array</span>[curIndex] &lt; <span class="built_in">array</span>[curIndex + <span class="number">1</span>])&#123;</span><br><span class="line">            curIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若根节点值小于子节点值，则交换</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[first] &lt; <span class="built_in">array</span>[curIndex])&#123;</span><br><span class="line">            swap(<span class="built_in">array</span>[first], <span class="built_in">array</span>[curIndex]);</span><br><span class="line">            first = curIndex;</span><br><span class="line">            curIndex = first * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用数组实现堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 最后一个非叶节点的节点索引</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">array</span>.size() / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        moveDown(<span class="built_in">array</span>, i, <span class="built_in">array</span>.size() - <span class="number">1</span>);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 生成堆</span></span><br><span class="line">    buildHeap(<span class="built_in">array</span>);</span><br><span class="line">    <span class="comment">// 堆顶、底索引</span></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>, last = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (first &lt;= last)&#123;</span><br><span class="line">        swap(<span class="built_in">array</span>[first], <span class="built_in">array</span>[last]);</span><br><span class="line">        last--;</span><br><span class="line">        moveDown(<span class="built_in">array</span>, first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h4><p>分治。</p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; copyArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid || j &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">			copyArray[k] = <span class="built_in">array</span>[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">			copyArray[k] = <span class="built_in">array</span>[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[j]) &#123;</span><br><span class="line">			copyArray[k] = <span class="built_in">array</span>[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			copyArray[k] = <span class="built_in">array</span>[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		<span class="built_in">array</span>[i] = copyArray[i - left];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortHelp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; copyArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		mergeSortHelp(<span class="built_in">array</span>, copyArray, left, mid);</span><br><span class="line">		mergeSortHelp(<span class="built_in">array</span>, copyArray, mid + <span class="number">1</span>, right);</span><br><span class="line">		merge(<span class="built_in">array</span>, copyArray, left, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">copyArray</span><span class="params">(<span class="built_in">array</span>)</span></span>;</span><br><span class="line">	mergeSortHelp(<span class="built_in">array</span>, copyArray, <span class="number">0</span>, <span class="built_in">array</span>.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><strong>计数排序</strong></h4><ul>
<li>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</li>
<li>步骤：</li>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = <span class="built_in">array</span>.front(),max = <span class="built_in">array</span>.front();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; <span class="built_in">array</span>[i])&#123;</span><br><span class="line">            min = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (max &lt; <span class="built_in">array</span>[i])&#123;</span><br><span class="line">            max = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录各元素出现次数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">counts</span><span class="params">(max - min + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">        counts[<span class="built_in">array</span>[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据记录的次数输出对应元素</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; counts.size(); j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = counts[j];</span><br><span class="line">        <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">            <span class="built_in">array</span>[index] = j + min;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><strong>桶排序</strong></h4><ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ul>
</li>
<li><p>适用于小范围（最大值和最小值差值较小），独立均匀分布的数据；</p>
</li>
<li><p>可以计算大批量数据，符合线性期望时间；</p>
</li>
<li><p>外部排序方式，需额外耗费n个空间；</p>
</li>
</ul>
<ul>
<li><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h4><ul>
<li><p>将各待比较元素数值统一数位长度，即对数位短者在前补零；</p>
</li>
<li><p>根据个位数值大小，对数组进行排序；</p>
</li>
<li><p>重复上一步骤，依次根据更高位数值进行排序，直至到达最高位；</p>
</li>
</ul>
</li>
<li><p>适用于正整数数据（若包含负数，那么需要额外分开处理)；</p>
</li>
<li><p>对于实数，需指定精度，才可使用此算法。</p>
</li>
</ul>
<h4 id="快排-vs-堆排序"><a href="#快排-vs-堆排序" class="headerlink" title="快排 vs 堆排序"></a><strong>快排 vs 堆排序</strong></h4><ul>
<li><p>堆排序比较的几乎都不是相邻元素，对cache极不友好，数学上的时间复杂度不代表实际运行的情况。快排常数小。</p>
</li>
<li><p>cache相比内存，读取速度非常快，所以cache会把一部分我们经常读取的数据暂时储存起来，以便下一次读取的时候，可以不必跑到内存去读，而是直接在cache里面找。</p>
</li>
<li>在堆排中，每一个操作都是不利于程序的局部性原理的，每次元素间的比较、数的调整等，都不是相邻或者尽可能附近的元素间的比较(堆调整每次都从堆底拿元素到堆顶然后向下进行调整），那么这就需要不断地在磁盘和内存间换入换出数据。反观快排，利用分而治之的方法，元素间的比较都在某个段内，局部性相当好。</li>
</ul>
<h4 id="STL-sort算法"><a href="#STL-sort算法" class="headerlink" title="STL sort算法"></a><strong>STL sort算法</strong></h4><p>​    STL的sort算法，数据量大时采用快排算法，分段采用快排（区间小于16）。一旦分段后的数据量小于某个门槛，为避免快排的递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，还会改用堆排序。</p>
<p>​    为什么用插入排序？因为插入排序在面对“几近排序”的序列时，表现更好。</p>
<h5 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h5><a href="/2021/02/04/%E6%8E%92%E5%BA%8F%E9%A2%98/" title="1.整理的排序题 leetcode">1.整理的排序题 leetcode</a>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2021/02/04/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<hr>
<p>刷题时遇到的一些数论知识，记录一下。</p>
<a id="more"></a>
<h4 id="给圆上三点，求园的周长"><a href="#给圆上三点，求园的周长" class="headerlink" title="给圆上三点，求园的周长"></a>给圆上三点，求园的周长</h4><blockquote>
<p>三角形面积：\(S = \frac{1}{2}absinB\)</p>
<p>根据海伦公式：\(S = \sqrt{p(p-a)(p-b)(p-c)}\)</p>
<p>根据正弦定理：\(\frac{a}{sinA} = \frac{b}{sinB} = \frac{c}{sinC} = d\)</p>
</blockquote>
<p>把\(sinA = \frac{a}{d}\)代入上式得：</p>
<script type="math/tex; mode=display">
d = \frac{abc}{2S}</script><p>外界圆周长： \( l = d*\pi\)</p>
<h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><blockquote>
<p><strong>贝祖定理</strong>：</p>
<p>如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。</p>
</blockquote>
<p>得到每两个相邻状态的x和y的转化，就可以在求gcd的同时对x和y进行求值：</p>
<p>\(a % b = a-(a/b)*b\)   代入：</p>
<p>\(b<em>x1 + (a-(a/b)</em>b)*y1\)</p>
<p>=a<em>y1 + b</em>(x1 – a/b*y1) = gcd</p>
<p> <code>发现</code>  \( x = y1 , y = x1 – a/b*y1\)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> k=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=k-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无限循环小数"><a href="#无限循环小数" class="headerlink" title="无限循环小数"></a>无限循环小数</h4><p><strong><em>万能公式</em></strong></p>
<p>设小数\(0.abcdefef\)…, 设其对应最简分数为:  \(\frac{x}{y}\)</p>
<p>设非循环节长度为c，循环节总长度为k，则</p>
<p>$\frac{x}{y}*10^{k+c} = abcdefef $ (将小数点后的数省略)</p>
<p>$\frac{x}{y}*10^{c} = abcd $  (将小数点后的数省略)</p>
<p>相减得到：</p>
<p>$\frac{x}{y} = \frac{abcdefef-abcd}{10^{c}*(10^k-1)}$</p>
<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p><strong>Homogeneous矩阵</strong>——写在 n 个独立位置上的数的和相等。</p>
<p>判断一个矩阵是否是Homogeneous矩阵，通过局部递推出规律：</p>
<p>对于一个n&times;n方阵，只要它的所有（n-1)&times;(n-1)子方阵是Homogeneous的，则该方阵是Homogeneous的；进一步递推可得，只要该方阵的所有2&times;2的子方阵符合两对角线相加相等，则该方阵是Homogeneous的。</p>
<h4 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a>最大子矩阵</h4><p>将二维数组转化为一维数组，再求最大子序列和。</p>
<p>（1）第一轮：第一次仅第一行合并；第二次1、2行合并；第三次1、2、3行合并…</p>
<p>（2）第二轮：第一次仅第二行合并；第二次2、3行合并；第三次2、3、4行合并…</p>
<p>（3）第三轮：第一次仅第三行合并；第二次3、4行合并；第三次3、4、5行合并…</p>
<p><strong>求最大子序列：</strong></p>
<blockquote>
<p>初始化ans=0，累加0到n-1个元素，每一步得到一个sum，如果某一步中sum&gt;ans，则更新ans，如果sum&lt;0，则重置sum为0，最终ans中储存的即为最大子序列和。</p>
</blockquote>
<h4 id="素数和"><a href="#素数和" class="headerlink" title="素数和"></a>素数和</h4><p><strong>哥德巴赫猜想：</strong> 每个大于4的偶数可以写成两个奇素数的和。</p>
<p>将每个数表示成4个素数的和：</p>
<p>N&lt;8 不能表示</p>
<p>N&gt;=8的偶数 先分解出2 2，N-=4</p>
<p>N&gt;=8的奇数 先分解出2 3，N-=5</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记——排序</title>
    <url>/2021/02/04/%E6%8E%92%E5%BA%8F%E9%A2%98/</url>
    <content><![CDATA[<p>leetcode刷题笔记——排序类。</p>
<a id="more"></a>
<h4 id="1-调整数组顺序使奇数位于偶数前面"><a href="#1-调整数组顺序使奇数位于偶数前面" class="headerlink" title="1.调整数组顺序使奇数位于偶数前面"></a>1.调整数组顺序使奇数位于偶数前面</h4><ul>
<li>不改变原有的相对关系。</li>
</ul>
<p>【法一】空间换时间，新开辟一个数组。</p>
<p>【法二】采用冒泡排序思想，奇数上浮到偶数左边。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=len<span class="number">-1</span>; j&gt;i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">array</span>[j]%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;<span class="built_in">array</span>[j<span class="number">-1</span>]%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    swap(<span class="built_in">array</span>[j],<span class="built_in">array</span>[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>【法三】双指针，先找到最前的偶数i，在向后找第一个奇数j，其间每一个数向后移，j移到i的位置上。</p>
<ul>
<li>可以改变相对关系</li>
</ul>
<p>【法一】首尾指针</p>
<p>奇偶交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span> ((nums[i]&amp;<span class="number">1</span>)==<span class="number">1</span>&amp;&amp;i&lt;j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((nums[j]&amp;<span class="number">1</span>)==<span class="number">0</span>&amp;&amp;i&lt;j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;j)</span><br><span class="line">                swap(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>【法二】快慢指针</p>
<p>搜索每个奇数放到该去的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                swap(nums[i],nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-把数组排成最小的数"><a href="#2-把数组排成最小的数" class="headerlink" title="2.把数组排成最小的数"></a><strong>2</strong>.把数组排成最小的数</h4><blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
</blockquote>
<p>实际上是字符串排序问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="keyword">static</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span>&#123;  <span class="comment">//函数指针</span></span><br><span class="line">    <span class="keyword">return</span> a+b&lt;b+a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val:numbers)&#123;</span><br><span class="line">        str.push_back(to_string(val));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(str.begin(),str.end(),cmp);</span><br><span class="line">    <span class="built_in">string</span> ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> s:str)&#123;</span><br><span class="line">        ans+=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>to_string c++11：数字转字符串</p>
</blockquote>
<h4 id="3-求逆序对"><a href="#3-求逆序对" class="headerlink" title="3.求逆序对"></a>3.求逆序对</h4><p>【法一】归并排序思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; copyArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (right&lt;=left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (right+left)/<span class="number">2</span>;</span><br><span class="line">        ans = mergeSort(<span class="built_in">array</span>,copyArray,left,mid)+mergeSort(<span class="built_in">array</span>,copyArray,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">int</span> i=left, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid||j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;mid)&#123;</span><br><span class="line">                copyArray[k] = <span class="built_in">array</span>[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j&gt;right)&#123;</span><br><span class="line">                copyArray[k] = <span class="built_in">array</span>[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i]&gt;<span class="built_in">array</span>[j])&#123;</span><br><span class="line">                copyArray[k] = <span class="built_in">array</span>[j];</span><br><span class="line">                ans+=j-left-k;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                copyArray[k] = <span class="built_in">array</span>[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            <span class="built_in">array</span>[i] = copyArray[i-left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">copyArray</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums,copyArray,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【法二】树状数组</p>
<p>。。。以后再补充</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>树专题</title>
    <url>/2021/02/05/%E6%A0%91/</url>
    <content><![CDATA[<p>剑指offer 树专题。</p>
<a id="more"></a>
<h4 id="1-重建二叉树"><a href="#1-重建二叉树" class="headerlink" title="1.重建二叉树"></a>1.重建二叉树</h4><p><strong>递归法</strong></p>
<ul>
<li>前序遍历的首元素 为 树的根节点 node 的值。</li>
<li>在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。</li>
<li>根据中序遍历中的左 / 右子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>根节点索引</th>
<th>中序遍历左边界</th>
<th>中序遍历右边界</th>
</tr>
</thead>
<tbody>
<tr>
<td>左子树</td>
<td><code>root + 1</code></td>
<td><code>left</code></td>
<td><code>i - 1</code></td>
</tr>
<tr>
<td>右子树</td>
<td><code>i - left + root + 1</code></td>
<td><code>i + 1</code></td>
<td><code>right</code></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">treenode</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(preorder[root]);</span><br><span class="line">        <span class="keyword">int</span> i = dic[preorder[root]];</span><br><span class="line">        node-&gt;left = treenode(root+<span class="number">1</span>,left,i<span class="number">-1</span>,preorder);</span><br><span class="line">        node-&gt;right = treenode(root+i-left+<span class="number">1</span>,i+<span class="number">1</span>,right,preorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.size(); i++)&#123;</span><br><span class="line">            dic[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treenode(<span class="number">0</span>,<span class="number">0</span>,inorder.size()<span class="number">-1</span>,preorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉树的镜像"><a href="#2-二叉树的镜像" class="headerlink" title="2.二叉树的镜像"></a>2.二叉树的镜像</h4><p><strong>时间复杂度 O(N)：</strong> 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。<br><strong>空间复杂度 O(N) ：</strong> 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N) 大小的栈空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-对称的二叉树"><a href="#3-对称的二叉树" class="headerlink" title="3.对称的二叉树"></a>3.对称的二叉树</h4><p><strong>【法一】递归</strong></p>
<ul>
<li>对称二叉树定义： 对于树中 <strong>任意两个对称节点</strong> L 和 R ，一定有：<ul>
<li>$L.val = R.val$：即此两对称节点值相等。</li>
<li>$L.left.val = R.right.val$ ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>$L.right.val = R.left.val$ ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png" alt="Picture1.png" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!left&amp;&amp;!right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (!left||!right||left-&gt;val!=right-&gt;val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> judge(left-&gt;left,right-&gt;right) &amp;&amp; judge(left-&gt;right,right-&gt;left);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> judge(root-&gt;left,root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>【法二】队列</p>
<h4 id="4-二叉树的深度"><a href="#4-二叉树的深度" class="headerlink" title="4.二叉树的深度"></a>4.二叉树的深度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-二叉搜索树"><a href="#5-二叉搜索树" class="headerlink" title="5.二叉搜索树"></a>5.二叉搜索树</h4><p>二叉搜索树的中序遍历为递增序列</p>
<h4 id="求二叉搜索树的第k大节点"><a href="#求二叉搜索树的第k大节点" class="headerlink" title="求二叉搜索树的第k大节点"></a>求二叉搜索树的第k大节点</h4><p>中序遍历的倒序：右、根、左</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;right,k);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-判断是不是平衡二叉树"><a href="#6-判断是不是平衡二叉树" class="headerlink" title="6.判断是不是平衡二叉树"></a>6.判断是不是平衡二叉树</h4><p>后序遍历+剪枝</p>
<ul>
<li><strong>时间复杂度 O(N)：</strong> N 为树的节点数；最差情况下，需要递归遍历树的所有节点。</li>
<li><strong>空间复杂度 O(N)：</strong> 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = depth(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (l==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = depth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (r==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(l-r)&lt;<span class="number">2</span>) <span class="keyword">return</span> max(l,r)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth(root)==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-求最近公共祖先"><a href="#6-求最近公共祖先" class="headerlink" title="6.求最近公共祖先"></a>6.求最近公共祖先</h4><p>递归查找 若当前节点的左子结点中含有p|q 且右子节点中也含有p|q 则返回当前节点；否则返回左/右子节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcde刷题笔记——栈队列堆</title>
    <url>/2021/02/05/%E6%A0%88%E9%98%9F%E5%88%97%E5%A0%86/</url>
    <content><![CDATA[<p>剑指offer中的栈队列堆部分。</p>
<a id="more"></a>
<h4 id="1-栈的压入、弹出序列"><a href="#1-栈的压入、弹出序列" class="headerlink" title="1.栈的压入、弹出序列"></a>1.栈的压入、弹出序列</h4><p>用一个栈来模拟。</p>
<p>若栈顶等于popped[j]，则弹出，否则将pushed[i]压入。</p>
<h4 id="2-最小的k个数"><a href="#2-最小的k个数" class="headerlink" title="2.最小的k个数"></a>2.最小的k个数</h4><p>【法一】排序</p>
<ul>
<li>时间复杂度$O(nlog n)$</li>
<li>空间复杂度$O(logn)$</li>
</ul>
<p>【法二】维护大顶堆</p>
<p>首先将前k个数插入大顶堆，从第k+1个数开始，若当前数小于堆顶，则弹出堆顶，将当前树插入。</p>
<ul>
<li>时间复杂度$O(nlog n)$</li>
<li>空间复杂度$O(k)$</li>
</ul>
<p>【法三】快排思想</p>
<h4 id="3-数据流中的中位数"><a href="#3-数据流中的中位数" class="headerlink" title="3.**数据流中的中位数"></a>3.**数据流中的中位数</h4><p>建立一个<strong>小顶堆</strong>A和<strong>大顶堆</strong>B，各保存列表的一般元素，且规定：</p>
<ul>
<li>A保存 <strong>较大</strong> 的一半，长度为$\frac{N}{2}$(N为偶数)或$\frac{N+1}{2}$(N为奇数)；</li>
<li>B保存 <strong>较小</strong> 的一半，长度为$\frac{N}{2}$(N为偶数)或$\frac{N-1}{2}$(N为奇数)；</li>
<li>随后，中位数可以仅根据A, B的堆顶元素计算得到。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/25837f1b195e56de20587a4ed97d9571463aa611789e768914638902add351f4-Picture1.png" alt="Picture1.png" style="zoom: 50%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; minHeap;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; maxHeap;</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size()==maxHeap.size())&#123;</span><br><span class="line">            maxHeap.push(num);</span><br><span class="line">            minHeap.push(maxHeap.top());</span><br><span class="line">            maxHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            minHeap.push(num);</span><br><span class="line">            maxHeap.push(minHeap.top());</span><br><span class="line">            minHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size()==maxHeap.size()&amp;&amp;minHeap.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(minHeap.top()+maxHeap.top())*<span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> minHeap.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-滑动窗口"><a href="#4-滑动窗口" class="headerlink" title="4.*滑动窗口"></a>4.*滑动窗口</h4><p>用deque维护非严格递减元素。</p>
<ul>
<li>deque 内仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 nums[i -1]，需将 deque 内的对应元素一起删除。</li>
<li>deque 内的元素 <strong>非严格递减</strong> ⇒ 每轮窗口滑动添加了元素 nums[j+1]，需将 deque 内所有 &lt; nums[j + 1] 的元素删除。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记——链表</title>
    <url>/2021/02/04/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>刷leetcode的链表题，记录了几道经典的题。<br><a id="more"></a></p>
<h4 id="1、反转链表-2"><a href="#1、反转链表-2" class="headerlink" title="1、反转链表 (2)"></a>1、反转链表 (2)</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>示例：</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<h5 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h5><p>记录下当前结点的上一个结点和下一个结点，当前节点的next指向上一个结点，再将当前节点设为下一个结点。</p>
<p><del>next不能在一开始赋值 要考虑空链表的情况</del></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="法二：递归（针对部分已经反转的链表）"><a href="#法二：递归（针对部分已经反转的链表）" class="headerlink" title="法二：递归（针对部分已经反转的链表）"></a>法二：递归（针对部分已经反转的链表）</h5><p>如$n_1$→…→$n_{k-1}$→$n_k$→$n_{k+1}$←…$n_m$<br>假设正处于$n_k$ 希望$n_{k+1}$指向$n_k$<br>∴$n_k$-&gt;$next$-&gt;$next$ = $n_k$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空间复杂度：$O(n)O(n)$ ，其中 $n$ 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 $n$ 层。</p>
<h4 id="2、找两个链表的交点-（160）"><a href="#2、找两个链表的交点-（160）" class="headerlink" title="2、找两个链表的交点 （160）"></a>2、找两个链表的交点 （160）</h4><h5 id="法一-暴力法"><a href="#法一-暴力法" class="headerlink" title="法一 暴力法"></a>法一 暴力法</h5><p>对链表A中的每一个结点$ a_i$，遍历整个链表 B 并检查链表 B 中是否存在结点和 $a_i$相同。</p>
<p><code>复杂度分析</code></p>
<ul>
<li>时间复杂度 : $O(mn)$。</li>
<li>空间复杂度 : $O(1)$。</li>
</ul>
<h5 id="法二-哈希表法"><a href="#法二-哈希表法" class="headerlink" title="法二 哈希表法"></a>法二 哈希表法</h5><p>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 $b_i$是否在哈希表中。若在，则 $b_i$为相交结点。</p>
<p><code>复杂度分析</code></p>
<ul>
<li>时间复杂度 : $O(m+n)$。</li>
<li>空间复杂度 : $O(m)$或$O(n)$。</li>
</ul>
<h5 id="法三-双指针法（妙）"><a href="#法三-双指针法（妙）" class="headerlink" title="法三 双指针法（妙）"></a>法三 双指针法（妙）</h5><ul>
<li><p>创建两个指针PA和PB，分别位于链表A和B的头结点，然后向后逐渐遍历。</p>
</li>
<li><p>PA到达链表尾部时，将他重定位到链表<strong><code>B</code></strong>的头结点（<strong><em>注意是链表B！！！</em></strong>）同样地，PB到达链表尾部时，将他重定位到链表A的头结点。</p>
</li>
<li><p>若某一时刻PA和PB相遇，则PA/PB为相交结点。</p>
</li>
<li><p>若两个链表存在相交，则它们的末尾节点必然相同。</p>
</li>
</ul>
<p><code>复杂度分析</code></p>
<ul>
<li>时间复杂度 : $O(m+n)$。<ul>
<li>空间复杂度 : $O(m)$或$O(n)$。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* PA = headA;</span><br><span class="line">        ListNode* PB = headB;</span><br><span class="line">        <span class="keyword">while</span> (PA!=PB)&#123;</span><br><span class="line">            PA = (PA?PA-&gt;next:headB);</span><br><span class="line">            PB = (PB?PB-&gt;next:headA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>！！！注意指针为空的情况！！！</strong></p>
<p><strong>每次遍历多走一个NULL，是因为如果没有交点，最后返回的也是NULL！！！</strong></p>
<h4 id="3、合并两个有序链表-（21）"><a href="#3、合并两个有序链表-（21）" class="headerlink" title="3、合并两个有序链表 （21）"></a>3、合并两个有序链表 （21）</h4><p><strong>法一 迭代</strong></p>
<p>不赘述 依次比较 向后链接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">       ListNode* L3=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);  <span class="comment">//设个头结点</span></span><br><span class="line">       ListNode* p = L3;</span><br><span class="line">       <span class="keyword">while</span> (l1&amp;&amp;l2)&#123;</span><br><span class="line">           <span class="keyword">if</span> (l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class="line">               p-&gt;next = l1;</span><br><span class="line">               l1 = l1-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               p-&gt;next = l2;</span><br><span class="line">               l2 = l2-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           p = p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (l1!=<span class="literal">nullptr</span>)</span><br><span class="line">           p-&gt;next = l1;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (l2!=<span class="literal">nullptr</span>)</span><br><span class="line">           p-&gt;next = l2;</span><br><span class="line">       <span class="keyword">return</span> L3-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>复杂度分析</code></p>
<ul>
<li><p>时间复杂度 : $O(m+n)$。</p>
</li>
<li><p>空间复杂度 : $O(1)$。</p>
</li>
</ul>
<p><strong>法二 递归</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next,l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>复杂度分析</code></p>
<ul>
<li><p>时间复杂度 : $O(m+n)$。</p>
</li>
<li><p>空间复杂度 : $O(m+n)$。     //消耗栈空间</p>
</li>
</ul>
<h4 id="4、删除倒数第N个结点"><a href="#4、删除倒数第N个结点" class="headerlink" title="4、删除倒数第N个结点"></a>4、删除倒数第N个结点</h4><blockquote>
<p>在对链表进行操作时，一种常用的技巧是添加一个<strong>哑节点</strong>（dummy node），它的 $next$ 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</p>
</blockquote>
<ul>
<li>一次遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        ListNode* first = second-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (n&amp;&amp;first)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!first&amp;&amp;n) <span class="keyword">return</span> head;     <span class="comment">//没有要删的</span></span><br><span class="line">        <span class="keyword">while</span> (first)&#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;  </span><br><span class="line">        ListNode* ans = dummy-&gt;next;    <span class="comment">//重要！！！不能直接返回head</span></span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、-两数相加-（445）"><a href="#5、-两数相加-（445）" class="headerlink" title="5、*两数相加 （445）"></a>5、*两数相加 （445）</h4><p>数字最高位位于链表开始位置，示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>
<p><strong>不改变原链表：</strong>采用栈，最后倒着连链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;a,b;</span><br><span class="line">        <span class="keyword">while</span> (l1)&#123;</span><br><span class="line">            a.push(l1-&gt;val);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2)&#123;</span><br><span class="line">            b.push(l2-&gt;val);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum,ci=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!a.empty()||!b.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = (a.empty()?<span class="number">0</span>:a.top());</span><br><span class="line">            <span class="keyword">int</span> num2 = (b.empty()?<span class="number">0</span>:b.top());</span><br><span class="line">            sum = (num1+num2+ci)%<span class="number">10</span>;</span><br><span class="line">            ci = (num1+num2+ci)/<span class="number">10</span>;</span><br><span class="line">            temp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">            p = temp;</span><br><span class="line">            <span class="keyword">if</span> (!a.empty()) a.pop();</span><br><span class="line">            <span class="keyword">if</span> (!b.empty()) b.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ci)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ListNode(ci);</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>复杂度分析</code></p>
<ul>
<li><p>时间复杂度 : $O(max(m,n))$。</p>
</li>
<li><p>空间复杂度 : $O(m+n)$。     //消耗栈空间</p>
</li>
</ul>
<p><del>不知道为啥用数组时间超了</del></p>
<p>先放着叭~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* temp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">100</span>],b[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1)&#123;</span><br><span class="line">            a[cnt1++] = l1-&gt;val;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2)&#123;</span><br><span class="line">            b[cnt2++] = l2-&gt;val;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt1--,cnt2--;</span><br><span class="line">        <span class="keyword">int</span> sum,ci=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt1||cnt2)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = (cnt1&gt;=<span class="number">0</span>?a[cnt1]:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> num2 = (cnt2&gt;=<span class="number">0</span>?b[cnt2]:<span class="number">0</span>);</span><br><span class="line">            sum = (num1+num2+ci)%<span class="number">10</span>;</span><br><span class="line">            ci = (num1+num2+ci)/<span class="number">10</span>;</span><br><span class="line">            temp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">            p = temp;</span><br><span class="line">            cnt1--,cnt2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ci)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ListNode(ci);</span><br><span class="line">            temp-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-回文链表"><a href="#6-回文链表" class="headerlink" title="6.*回文链表"></a>6.*回文链表</h4><p><strong>法一 拷贝到数组里 双指针比较</strong></p>
<p><code>复杂度分析</code></p>
<ul>
<li>时间复杂度 : $O(n)$。</li>
<li>空间复杂度 : $O(n)$。     </li>
</ul>
<p><strong>法二 链表后半部分反转</strong></p>
<ol>
<li>找到前半部分链表的尾节点。</li>
<li>反转后半部分链表。</li>
<li>判断是否回文。</li>
<li>恢复链表。</li>
</ol>
<p>【步骤一】计算链表节点的数量，再找到前半部分的尾节点；也可以使用<strong>快慢指针</strong>在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。</p>
<p>【步骤四】与步骤二函数相同，再反转一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode* firstHalfEnd = endOfFirstHalf(head);</span><br><span class="line">        ListNode* secondHalfStart = reverseList(firstHalfEnd-&gt;next);</span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = secondHalfStart;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd-&gt;next = reverseList(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstHalf</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="7-奇偶链表"><a href="#7-奇偶链表" class="headerlink" title="7.奇偶链表"></a>7.奇偶链表</h4><p>把节点编号为奇数的放在前面，偶数放在后面。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>一边扫描，<strong>时间复杂度O(n)，空间复杂度O(1).</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* odd_p = head;</span><br><span class="line">        ListNode* even_head = head-&gt;next;</span><br><span class="line">        ListNode* even_p = even_head;</span><br><span class="line">        <span class="keyword">while</span> (even_p&amp;&amp;even_p-&gt;next)&#123;</span><br><span class="line">            odd_p-&gt;next = even_p-&gt;next;</span><br><span class="line">            odd_p = odd_p-&gt;next;</span><br><span class="line">            even_p-&gt;next = odd_p-&gt;next;</span><br><span class="line">            even_p = even_p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd_p-&gt;next = even_head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ static详解</title>
    <url>/2021/02/10/statics/</url>
    <content><![CDATA[<p>C++ static静态成员变量和静态成员函数。</p>
<p>巩固回忆一下之前所学。</p>
<a id="more"></a>
<h2 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h2>
<h4 id="1类中的静态成员变量"><a class="markdownIt-Anchor" href="#1类中的静态成员变量"></a> 1.类中的静态成员变量</h4>
<ul>
<li>
<p>用于在多个对象之间共享数据，对象 a 改变了某份数据后对象 b 可以检测到。</p>
</li>
<li>
<p>static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为该变量分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了改静态变量，也会影响到其他对象。</p>
</li>
<li>
<p>static 成员变量必须在类声明的外部初始化，具体形式为：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type class::name &#x3D; value;</span><br></pre></td></tr></table></figure>
<p>​	<strong>注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。</strong></p>
<p>​		<strong>初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。</strong></p>
<p>​		<strong>static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存。</strong></p>
<h4 id="2类中的静态成员函数"><a class="markdownIt-Anchor" href="#2类中的静态成员函数"></a> 2.类中的静态成员函数</h4>
<p>​	普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p>
<p>​	实际上，他就是增加了类的访问权限的全局函数。</p>
<h4 id="3全局静态变量"><a class="markdownIt-Anchor" href="#3全局静态变量"></a> 3.全局静态变量</h4>
<ul>
<li>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。</p>
</li>
<li>
<p>内存中的位置：静态存储区，在整个程序运行期间一直存在。</p>
</li>
<li>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
</li>
<li>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
</li>
</ul>
<p>​	<strong>全局变量和全局静态变量的区别</strong></p>
<ul>
<li>全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。</li>
<li>全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。</li>
</ul>
<h4 id="4局部静态变量"><a class="markdownIt-Anchor" href="#4局部静态变量"></a> 4.局部静态变量</h4>
<ul>
<li>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
</li>
<li>
<p>内存中的位置：静态存储区</p>
</li>
<li>
<p>静态局部变量在程序执行到该对象的声明处时被首次初始化，以后的函数调用不再进行初始化。如果没有显式初始化，会被程序自动初始化为 0。</p>
</li>
<li>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ this指针</title>
    <url>/2021/02/10/this/</url>
    <content><![CDATA[<h3 id="this-指针"><a class="markdownIt-Anchor" href="#this-指针"></a> this 指针</h3>
<a id="more"></a>
<ol>
<li>
<p><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</p>
</li>
<li>
<p>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</p>
</li>
<li>
<p>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</p>
</li>
<li>
<p><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</p>
</li>
<li>
<p><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>inline</title>
    <url>/2021/02/10/inline/</url>
    <content><![CDATA[<blockquote>
<p>在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 <strong>inline</strong> 修饰符，表示为内联函数。</p>
</blockquote>
<a id="more"></a>
<ul>
<li><p><strong>inline使用限制</strong></p>
<p>inline 只适合涵数体内代码简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。</p>
</li>
<li><p>inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p>
</li>
<li><p>类中的成员函数与inline</p>
<p><strong>定义</strong>在类中的<strong>成员函数</strong>默认都是<strong>内联的</strong>，如果在类定义时就在类内给出函数定义，那当然最好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  &#125; <span class="comment">// 自动地成为内联函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 <strong>inline</strong>，否则就认为不是内联的。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关键字 <code>inline</code> 必须与函数定义体放在一起才能使函数成为内联，仅将 <code>inline</code> 放在函数声明前面不起任何作用。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125; <span class="comment">// inline 与函数定义体放在一起</span></span><br></pre></td></tr></table></figure></li>
<li><p>慎用</p>
<ul>
<li>内联是以<strong>代码膨胀（复制）</strong>为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 </li>
<li>如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>inline</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索总结 BinarySearch</title>
    <url>/2021/02/11/binarysearch/</url>
    <content><![CDATA[<p>二分搜索几种情况总结以及例题分享。</p>
<a id="more"></a>
<ul>
<li>
<h4 id="不重复元素寻找目标值最基本"><a class="markdownIt-Anchor" href="#不重复元素寻找目标值最基本"></a> 不重复元素寻找目标值（最基本）</h4>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找不到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该模板的应用：</p>
<p>1.<a href="https://leetcode-cn.com/problems/sqrtx/">leetcode——x的平方根</a></p>
<p>2.<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">leetcode——猜数字大小</a></p>
<p>3.<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">leetcode——搜索旋转排序数组</a>  有点妙！题解：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-sou-suo-xuan-zhuan-pai-xu-shu-tvwx6/">leetcode题解C++</a></p>
<ul>
<li>
<h4 id="找当前索引以及直接右邻索引"><a class="markdownIt-Anchor" href="#找当前索引以及直接右邻索引"></a> 找当前索引以及直接右邻索引</h4>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size();</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该模板的应用：</p>
<p>1.<a href="https://leetcode-cn.com/problems/first-bad-version/">leetcode——第一个错误的版本</a></p>
<p>2.<a href="https://leetcode-cn.com/problems/find-peak-element/">leetcode——寻找峰值</a></p>
<p>3.<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">leetcode——寻找旋转排序数组中的最小值</a></p>
<p>4.<a href="https://leetcode-cn.com/problems/find-k-closest-elements/">leetcode——找到k个最接近的元素</a>  很妙的思路！</p>
<ul>
<li>
<h4 id="找当前索引以及直接左右邻索引"><a class="markdownIt-Anchor" href="#找当前索引以及直接左右邻索引"></a> 找当前索引以及直接左右邻索引</h4>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h4 id="找元素出现的第一个位置"><a class="markdownIt-Anchor" href="#找元素出现的第一个位置"></a> 找元素出现的第一个位置</h4>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若没找到，返回大于该元素的第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);  <span class="comment">//不容易移除</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//当目标值小于等于nums[mid]时，继续在左区间检索，找到第一个数</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//目标值大于nums[mid]时，则在右区间继续检索，找到第一个等于目标值的数</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h4 id="找元素出现的最后一个位置"><a class="markdownIt-Anchor" href="#找元素出现的最后一个位置"></a> 找元素出现的最后一个位置</h4>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若没找到，返回小于该元素的第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upperBound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//移动左指针情况</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[mid]) &#123;</span><br><span class="line">                 left = mid + <span class="number">1</span>; </span><br><span class="line">            <span class="comment">//移动右指针情况</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相关题目：</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode——在排序数组中查找元素的第一个和最后一个位置</a></p>
]]></content>
      <tags>
        <tag>BinarySearch</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树/字典树/trie树</title>
    <url>/2021/02/18/trie/</url>
    <content><![CDATA[<p><strong>定义</strong></p>
<blockquote>
<p>又称单词查找树，字典树，Trie树，是一种树形结构，是一种<code>哈希树</code>的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：<strong>利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</strong></p>
</blockquote>
<a id="more"></a>
<p><img src="D:%5Cblog%5Cmyblog%5Csource_posts%5C3a0be6938b0a5945695fcddd29c74aacc7ac30f040f5078feefab65339176058-file_1575215106942.png" alt="3a0be6938b0a5945695fcddd29c74aacc7ac30f040f5078feefab65339176058-file_1575215106942" /></p>
<p><strong>前缀树的性质：</strong></p>
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li>
<li>每个节点的所有子节点包含的字符都不相同</li>
</ul>
<p><strong>常用操作：</strong></p>
<ul>
<li><strong>类定义</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>插入单词</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> w : word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;next[w-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node-&gt;next[w-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 O(m)，其中 m 为键长。</p>
</li>
<li>
<p>空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m) 空间。</p>
</li>
<li>
<p><strong>查找单词</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> w : word) &#123;</span><br><span class="line">        node = node-&gt;next[w - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 : O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 m<em>m</em> 次操作。</p>
</li>
<li>
<p>空间复杂度 : O(1)。</p>
</li>
<li>
<p><strong>前缀匹配</strong></p>
<p>判断 Trie 中是否有以 prefix 为前缀的单词</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> w : prefix) &#123;</span><br><span class="line">        node = node-&gt;next[w-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度 : O(m)。</li>
<li>空间复杂度 : O(1)。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2021/02/20/segmentTree/</url>
    <content><![CDATA[<h3 id="什么是线段树"><a class="markdownIt-Anchor" href="#什么是线段树"></a> 什么是线段树</h3>
<p>​		线段树，是一种<strong>二叉搜索树</strong>。它将一段区间划分为若干<strong>单位区间</strong>，每一个节点都储存着一个区间。它支持区间求和，区间最大值，区间修改，单点修改等操作。线段树的思想和分治思想很相像。<br />
​		线段树的每一个节点都储存着一段区间[L…R]的信息，其中<strong>叶子节点</strong>L=R。它的大致思想是：将一段大区间平均地划分成2个小区间，每一个小区间都再平均分成2个更小区间……以此类推，直到每一个区间的L等于R（这样这个区间仅包含一个节点的信息，无法被划分）。通过对这些区间进行修改、查询，来实现对大区间的修改、查询。<br />
​		这样一来，每一次修改、查询的时间复杂度都只为$O ( log n ) $。</p>
<a id="more"></a>
<h3 id="线段树原理"><a class="markdownIt-Anchor" href="#线段树原理"></a> 线段树原理</h3>
<p>​		线段树主要是把一段大区间<strong>平均地划分</strong>成两段小区间进行维护，再用小区间的值来更新大区间。这样既能保证正确性，又能使时间保持在log级别（因为这棵线段树是平衡的）。也就是说，一个[ L , R ] 的区间会被划分成[ L , ⌊ (L + R)/2 ⌋ ] 和[ ⌊ (L + R)/ 2 ⌋ + 1 , R ] 这两个小区间进行维护，直到 L = R 。<br />
​		下图就是一棵[ 1 , 10 ] 的线段树的分解过程（相同颜色的节点在同一层）</p>
<p><img src="D:%5Cblog%5Cmyblog%5Csource_posts%5C20180.jpg" alt="20180" /></p>
<h3 id="存储方式"><a class="markdownIt-Anchor" href="#存储方式"></a> 存储方式</h3>
<p>通常用的都是<strong>堆式储存法</strong>，即编号为k的节点的左儿子编号为2k，右儿子编号为2k + 1，父节点编号为⌊ k/2 ⌋，用<strong>位运算</strong>优化一下，以上的节点编号就变成了<code>k&lt;&lt;1</code>, <code>k&lt;&lt;1|1</code>, <code>k&gt;&gt;1</code>。</p>
<p>在表示线段树的时候都要在数据量n的情况下多开更大的空间，一般都是开四倍。</p>
<p><strong>线段树定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> lazy[MAX&lt;&lt;<span class="number">2</span>]; <span class="comment">//懒惰标记</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	sum[k] = sum[k&lt;&lt;<span class="number">1</span>]+sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">		sum[k] = number[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	pushup(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单点修改"><a class="markdownIt-Anchor" href="#单点修改"></a> 单点修改</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//k为当前节点的编号，要把编号为x的数字修改成y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a[k].l==a[k].r)&#123;</span><br><span class="line">        a[k].sum=y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(a[k].l+a[k].r)/<span class="number">2</span>;<span class="comment">//计算下一层子区间的左右边界</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) change(k*<span class="number">2</span>,x,y);<span class="comment">//递归到左儿子</span></span><br><span class="line">	<span class="keyword">else</span> change(k*<span class="number">2</span>+<span class="number">1</span>,x,y);<span class="comment">//递归到右儿子</span></span><br><span class="line">	update(k);<span class="comment">//记得更新点k的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改"><a class="markdownIt-Anchor" href="#区间修改"></a> 区间修改</h3>
<p>区间修改大体可以分为两步：</p>
<ol>
<li>找到区间中全部都是要修改的点的线段树中的区间</li>
<li>修改这一段区间的所有点</li>
</ol>
<p>从根节点出发，一直往下走，直到当前区间中的元素全部都是被修改元素。</p>
<ul>
<li>
<p>若当前区间全都是要修改的区间，则修改sum和懒惰标记，return</p>
</li>
<li>
<p>当左区间包含修改的区间时，就递归到左区间；</p>
</li>
<li>
<p>当区右间包含修改的区间时，就递归到右区间；</p>
</li>
</ul>
<p><strong>！修改要用到懒惰标记！</strong></p>
<h3 id="懒惰标记"><a class="markdownIt-Anchor" href="#懒惰标记"></a> 懒惰标记</h3>
<p><strong>标记的含义：本区间已经被更新过了，但是子区间却没有被更新过，被更新的信息是什么（区间求和只用记录有没有被访问过，而区间加减乘除等多种操作的问题则要记录进行的是哪一种操作）</strong><br />
这里再引入两个很重要的东西：<strong>相对标记</strong>和<strong>绝对标记</strong>。</p>
<h4 id="相对标记"><a class="markdownIt-Anchor" href="#相对标记"></a> 相对标记</h4>
<blockquote>
<p><strong>相对标记</strong>指的是可以共存的标记，且打标记的顺序与答案无关，即标记可以叠加。 比如说给一段区间中的所有数字都+a，我们就可以把标记叠加一下，比如上一次打了一个+1的标记，这一次要给这一段区间+2，那么就把+1的标记变成+3。</p>
</blockquote>
<h4 id="绝对标记"><a class="markdownIt-Anchor" href="#绝对标记"></a> 绝对标记</h4>
<blockquote>
<p><strong>绝对标记</strong>是指不可以共存的标记，每一次都要先把标记下传，再给当前节点打上新的标记。这些标记不能改变次序，否则会出错。 比如说给一段区间的数字重新赋值，或是给一段区间进行多种操作。</p>
</blockquote>
<p>这样一来，我们每一次修改区间时只要找到目标区间就可以了，给它打上懒惰标记，不用再向下递归到叶节点。</p>
<p>区间+x的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeSegment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=nl &amp;&amp; nr&lt;=r)&#123;</span><br><span class="line">		sum[k]+=(nr-nl+<span class="number">1</span>)*x;</span><br><span class="line">		lazy[k]+=x;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (nl+nr)/<span class="number">2</span>;</span><br><span class="line">	pushdown(k,nl,nr);</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=mid) changeSegment(k&lt;&lt;<span class="number">1</span>,l,r,x,nl,mid);</span><br><span class="line">	<span class="keyword">if</span> (r&gt;mid) changeSegment(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x,mid+<span class="number">1</span>,nr);</span><br><span class="line">	pushup(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下传标记"><a class="markdownIt-Anchor" href="#下传标记"></a> 下传标记</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lazy[k])&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (nl+nr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		sum[k&lt;&lt;<span class="number">1</span>] +=(<span class="keyword">long</span> <span class="keyword">long</span>)(mid-nl+<span class="number">1</span>)*lazy[k];</span><br><span class="line">		sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=(<span class="keyword">long</span> <span class="keyword">long</span>)(nr-mid)*lazy[k];</span><br><span class="line">		lazy[k&lt;&lt;<span class="number">1</span>]+=lazy[k];</span><br><span class="line">		lazy[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[k];</span><br><span class="line">		lazy[k] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间查询"><a class="markdownIt-Anchor" href="#区间查询"></a> 区间查询</h3>
<ol>
<li>当查找区间在当前区间的左子区间时，递归到左子区间；</li>
<li>当查找区间在当前区间的右子区间时，递归到右子区间；</li>
<li>否则，这个区间一定是跨越两个子区间的，我们就把它切成2块，分在两个子区间查询。最后把答案合起来处理。</li>
</ol>
<p><em><strong>记得在查询之前下传标记！！！</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=nl &amp;&amp; nr&lt;=r) <span class="keyword">return</span> sum[k];</span><br><span class="line">	<span class="keyword">if</span> (lazy[k]) pushdown(k,nl,nr);</span><br><span class="line">	<span class="keyword">int</span> mid = (nl+nr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=mid) ans+=query(k&lt;&lt;<span class="number">1</span>,l,r,nl,mid);</span><br><span class="line">	<span class="keyword">if</span> (r&gt;mid) ans+=query(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,mid+<span class="number">1</span>,nr);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间乘和区间加"><a class="markdownIt-Anchor" href="#区间乘和区间加"></a> 区间乘和区间加</h3>
<p><strong>先乘后加！！</strong></p>
<p><strong>所谓先乘后加就是在做乘法的时候把加法标记也乘上这个数，在后面做加法的时候直接加就行了。</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P3373">【模板题】 洛谷 线段树2</a></p>
<h4 id="区间x的代码"><a class="markdownIt-Anchor" href="#区间x的代码"></a> 区间*x的代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=nl &amp;&amp; nr&lt;=r)&#123;</span><br><span class="line">		sum[k]*=x;</span><br><span class="line">		mul[k]*=x;</span><br><span class="line">		add[k]*=x;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (nl+nr)/<span class="number">2</span>;</span><br><span class="line">	pushdown(k,nl,nr);</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=mid) update2(k&lt;&lt;<span class="number">1</span>,l,r,x,nl,mid);</span><br><span class="line">	<span class="keyword">if</span> (r&gt;mid) update2(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x,mid+<span class="number">1</span>,nr);</span><br><span class="line">	pushup(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下传标记-2"><a class="markdownIt-Anchor" href="#下传标记-2"></a> 下传标记</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (add[k]!=<span class="number">0</span>||mul[k]!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (nl+nr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		sum[k&lt;&lt;<span class="number">1</span>] = sum[k&lt;&lt;<span class="number">1</span>]*mul[k]+(mid-nl+<span class="number">1</span>)*add[k];</span><br><span class="line">		sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[k]+(nr-mid)*add[k];</span><br><span class="line">		mul[k&lt;&lt;<span class="number">1</span>] = mul[k]*mul[k&lt;&lt;<span class="number">1</span>];</span><br><span class="line">		mul[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = mul[k]*mul[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">		add[k&lt;&lt;<span class="number">1</span>] = add[k&lt;&lt;<span class="number">1</span>]*mul[k]+add[k];</span><br><span class="line">		add[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = add[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[k]+add[k];</span><br><span class="line">		mul[k] = <span class="number">1</span>;</span><br><span class="line">		add[k] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> add[MAX&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mul[MAX&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> number[MAX];</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	sum[k] = (sum[k&lt;&lt;<span class="number">1</span>]+sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	add[k] = <span class="number">0</span>;</span><br><span class="line">	mul[k] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">		sum[k] = number[l]%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	pushup(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (nl+nr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	sum[k&lt;&lt;<span class="number">1</span>] =(sum[k&lt;&lt;<span class="number">1</span>]*mul[k]+(mid-nl+<span class="number">1</span>)*add[k])%p;</span><br><span class="line">	sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] =(sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[k]+(nr-mid)*add[k])%p;</span><br><span class="line">	mul[k&lt;&lt;<span class="number">1</span>] = (mul[k]*mul[k&lt;&lt;<span class="number">1</span>])%p;</span><br><span class="line">	mul[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = (mul[k]*mul[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%p;</span><br><span class="line">	add[k&lt;&lt;<span class="number">1</span>] = (add[k&lt;&lt;<span class="number">1</span>]*mul[k]+add[k])%p;</span><br><span class="line">	add[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = (add[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*mul[k]+add[k])%p;</span><br><span class="line">	mul[k] = <span class="number">1</span>;</span><br><span class="line">	add[k] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeSegment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=nl &amp;&amp; nr&lt;=r)&#123;</span><br><span class="line">		sum[k] = (sum[k]+(nr-nl+<span class="number">1</span>)*x)%p;</span><br><span class="line">		add[k] = (x+add[k])%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (nl+nr)/<span class="number">2</span>;</span><br><span class="line">	pushdown(k,nl,nr);</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=mid) changeSegment(k&lt;&lt;<span class="number">1</span>,l,r,x,nl,mid);</span><br><span class="line">	<span class="keyword">if</span> (r&gt;mid) changeSegment(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x,mid+<span class="number">1</span>,nr);</span><br><span class="line">	pushup(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=nl &amp;&amp; nr&lt;=r)&#123;</span><br><span class="line">		sum[k] = (sum[k]*x)%p;</span><br><span class="line">		mul[k] = (mul[k]*x)%p;</span><br><span class="line">		add[k] = (add[k]*x)%p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (nl+nr)/<span class="number">2</span>;</span><br><span class="line">	pushdown(k,nl,nr);</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=mid) update2(k&lt;&lt;<span class="number">1</span>,l,r,x,nl,mid);</span><br><span class="line">	<span class="keyword">if</span> (r&gt;mid) update2(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x,mid+<span class="number">1</span>,nr);</span><br><span class="line">	pushup(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=nl &amp;&amp; nr&lt;=r) <span class="keyword">return</span> sum[k];</span><br><span class="line">	pushdown(k,nl,nr);</span><br><span class="line">	<span class="keyword">int</span> mid = (nl+nr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=mid) ans = (ans+query(k&lt;&lt;<span class="number">1</span>,l,r,nl,mid))%p;</span><br><span class="line">	<span class="keyword">if</span> (r&gt;mid) ans = (ans+query(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,mid+<span class="number">1</span>,nr))%p;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,choice;</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,number+i);</span><br><span class="line">	&#125;</span><br><span class="line">	build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;choice);</span><br><span class="line">		<span class="keyword">if</span> (choice==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">			update2(<span class="number">1</span>,x,y,k,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (choice==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">			changeSegment(<span class="number">1</span>,x,y,k,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,query(<span class="number">1</span>,x,y,<span class="number">1</span>,n)%p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
